
We would like to thank the reviewers for the extremely detailed suggestions on
improving and polishing our pearl submission. In return, this response
addresses major shared concerns in the first 500 words, and then replies to any
additional questions in more detail.

1. As the reviewers clearly realized, the pearl uses Video as a running
example to illustrate the idea of language-oriented programming (LOP) in
Racket. It is not a research result on creating a video-editing DSL.  In
particular, though we have used Video to produce the RacketCon '16 channel on
YouTube, the language definitely has its short-comings. For example, 
we would not currently recommend using it to directly manipulate videos.

That said, the paper should explain interactive capabilities that *are*
available in Video:
real-time previews like those found in NLVEs, the editing capabilities pf
NLVE widgets, and the full REPL interactivity. We will extend Section 7 to
discuss these features.

2. The paper distinguishes between two parts of a programming language:
_linguistic constructs_ and _run-time primitives_. An example of the former
includes new syntax (e.g., list comprehension for creating playlists or new
binding forms) while the latter refers to explicit functions from the prelude
(e.g., `green`) or implicit capabilities (not for Video, but think GC).

3. The revision of the paper will clarify that Video is *not* tied to
DrRacket or a specific video-rendering framework. First, while Video
programmers benefit from using DrRacket and its embedded NLVE widgets, they
can use any old editor to create Video programs if they don't need such
features.

Second, the Video language is also parametric over the rendering library. In
the early stages of Video's development, we switched between two independent
renderers, libmlt and gstreamer, and we have even considered writing a
functional renderer within Racket. We will briefly discuss this flexibility in 
the revised paper.

4. The reviewers point out a mismatch between the typing rules presented in
figure 8 and the implementations of typing rules in figure 9. Our revision will
add rules to figure 8 that describe the implementation in figure 9.

5. Though a discussion of related work is not crucial in a functional pearl, we
wish to contrast Racket's LOP approach from the DSL approach of other
languages, e.g., Haskell. Our related work should, however, improve its
discussion of both pros and cons of other approaches. For example, a lazy DSL
or an embedded DSL with a type system like Haskell's definitely benefits from
the Haskell approach and should not be created in Racket. Similarly, developers
interested in creating a graphically-edited DSL might be better using one of
the mature language workbenches like MetaEdit+.

-----------------------------------------------------------------------------

Extended responses to each individual review:

===========================================================================
Review #93A

> is there any way to get quick, REPL-style feedback?

 Video inherits Racket's REPL and thus supports an this kind of workflow with
 functions like `preview`. Even better, DrRacket directly supports Video
 programming via a "Preview" button. A low-res preview starts quickly (a few
 seconds max) and the current video is played in real-time, with standard
 playback controls.

> What if I want to preview just the middle five seconds of my video?

Use the provided playback controls, or supply `preview with `#:start` and
`#:end` keywords to extract the clip you want to render.

> The figure 11 ... if we want to avoid a list of magic numbers ...

A human manually appends the slides together in the same fashion one
would do with an NLVE. Section 7 shows that using Video does not
prevent authors from editing videos with an NLVE when appropriate. And
not only can the result of the NLVE be put into the program, but a
programmer can embed NLVE itself into the program.

We revise Section 7 with more details on the implementation of our NLVE widgets.

> The discussion of the type system in section 6 seems a bit half-baked.

We will add rules in figure 8 to match the code in figure 9.

> The bottom of p.17 says "A type error is signaled ...

We will add an example to illustrate this error.

> p.2: "boring functional languages... Why put readers on the defensive?

We look to will tone down the prose without affecting the playful nature of the paper. Would removing names of individual languages be sufficient?

> p.3: "the ability to supply additional run-time primitives with a new language" -- how is this distinct from "new linguistic constructs" listed above?

See above. Run-time primitives are functions, e.g., producers. Linguistic constructs are syntactic extensions, e.g., new binding forms.

> p.3: "Using a tool's official plug-in...yields a plug-in that is tightly coupled with its tool" -- sure, but isn't Video tightly coupled with Racket?

Also see above.

Video's integration with Racket differs from NLVEs in 2 ways.

First, while Video programmers benefit from extra plugins in DrRacket, they may
use any editor.

Second, Video programs are agnostic to specific rendering libraries in a way
that NLVEs are not. In fact, in the early stages of Video's development, we
smoothly switched between two independent renderers. We will discuss this
capability this in the revised paper.

> p.4, figure 1: When a playlist has `#:start` and `#:end` keyword arguments, does that mean start of first clip/end of last clip? 

The `#:start` and `#:end` keywords modify the behavior of a producer.
Adding it to a playlist treats the entire playlist like a producer. So
for example, the start position can be after the first clip. This may
seem like a silly thing to do directly, but is needed to properly
abstract over clips.

> p.5: "The literature survey suggests that..." Whose literature survey?

Our survey in section 2.

> p.5: "What is missing, is the audio part" -- why not include the audio part?

We intentionally omitted audio to simplify the example.

> p.8: "...shortens the length of the `playlist`" -- Be clear about whether you mean shorter in time, or just shorter in number of clips.

Shortens the time.

> p.9: Since multitracks play producers in parallel, what if they're different lengths?  I would imagine they'd start at the same time, but the image on this page makes it look otherwise.

Each *track* starts playing at the same time. Authors insert `blank`s
to delay the start time of a track's producer. The length of a
multitrack is the length of its longest track, with implicit blanks
added at the end of every other track.

> p.11: "another DSL, one designed specifically for implementing Video" -- is this referring to the "Video FFI" DSL introduced later?  I think it would be helpful to mention the name of it here.

We did not give it a name but we will come up with one in the revised paper.

> p.13: The first explanation of `syntax-parse` is here, but it first occurs on p.11 (figure 4).

We will briefly introduce syntax-parse on page 11.

> p.13: The description beginning with "This auxiliary syntax transformer..." does not seem to quite match up with either of the two patterns in the `syntax-parse` in `video-begin` in Figure 6.

`b1` is one of the expressions that belong with `body ...`

> p.13: "The last piece of the `begin` block is `code`."  Huh?

This is a typo and should be deleted.

> p.14: "The syntax transformer for function bodies..." -- To what code is this paragraph referring?

We will add a "not shown" to that sentence.

> p.15: "It errors if a bad input or output type passes through this interface." -- I didn't quite follow this.  What would a bad output type be?  Is NULL bad, or do you mean it errors if the result is *neither* a profile object nor NULL?

In this case NULL is bad output `mlt-profile-init` throws an error error.

> p.16: `cut-producer` appears here for the first time.  Should it have been introduced earlier?

Previously `#:start` and `#:end` were sufficient (and cleaner) ways to
cut producers. Its needed here to abstract over the specific producer
being cut.

> p.19: "Turnstile reuses Racket's lexical scoping to implement the type environment." I am not sure I understand.  Does this mean that lexical scoping somehow frees us from needing to write down a context in the conclusion of the typing rules?

This is correct. A type rule only specifies new bindings to add to the
type envirnoment, analogous to `let`. Existing bindings are propagated according to standard lexical scope behavior.

> p.19: "elaborating the lambda body `e` may generate additional side conditions, `new-Cs`..." So, `get-captured-Cs` is something provided by Turnstile?

These are user-defined functions, though their definitions are not included in the paper. We will make sure this is clear in the prose.

> p.21, figure 11: It would be easier to understand this figure if the numbers in the NLVE widget on the right were in the same units as 10, 15, 16, 16... on the left.

We will fix this in the revised paper.
  
===========================================================================
Review #93B

> emphasizes the importance of building water-tight abstractions, but this is not really demonstrated in the paper.

This mostly alludes to benefits provided by syntax-parse over syntax-case, as explained in the ICFP 2010 paper. Thus, any abstraction created with syntax-parse, e.g., #%module-begin in figure 6, or the type rules in figure 9 (implicitly) enjoy these benefits.

> "adding new linguistic constructs" at this point I wondered: what
really counts as a linguistic construct?

Also see above.

Linguistic constructs are syntactic extensions such as new binding forms that cannot be created with standard abstractions such as functions.

> does "video clip" include both video and audio? is an "audio clip"
  just a special instance of a "video clip"? 

A video clip may contain audio, but does not need to. You are correct
that an audio clip is just a special case of video clip that contains
only audio.
  
> what is the relationship between a "time line" and a "track"?  

A video only has one timeline, which is composed of several tracks
layered on top of each other. (You are correct in your understanding.)

> In fact, the notion of "track" seems to disappear as the paper goes on.

Multitracks are groups of tracks. Video breaks down the traditional
notion of one global timeline with one global sequence of tracks
playing in parallel. Instead, it makes these concepts local, and so
each producer in a multitrack is itself a track.

> "*Obviously* a screen displaying the result can play only a single
track for video" this wasn't obvious to me, especially when it was
said that audio tracks can be played together.  Both seem to me like
just summing information, especially if video has alpha channels or
something.

The 'or something' that is the key here. There are a lot of
different meanings that placing one track over another could take.
Should the colors be added together, should one track be a mask for
the other, should it replace only one color in the first track with
the contents of the second track? All of these are valid compositions,
and this is why a dedicated compositor is required to say how they get
put together. If none is provided, Video assumes that you just wanted
to place one track on top of the other, with no fading. If there is an
alpha channel in the track on top it makes sense for the one
underneath it to 'fade through'.

While audio also has many ways it can be combined, simply playing the
two streams at the same time is a reasonable thing to do. If the audio
signals are added together, both streams appear to come out of the
speaker at the same time.

> <Fig. 1 through page 7, pages 9-24>

Thank you for the detailed prose improvements. We will work to include them in
the revised version of the paper.

> An apt analogy for sequential transitions is that they act like infix
associative binary operators on producers, like addition and
multiplication, except always in the context of a playlist.

This analogy is correct.

> "specify the coordinates of the top-left corner of the producer" which
producer?  the first one?  the second one?  the resulting one?

The coordinates of the bottom producer, the one that the top one is
being placed on top of.

> Figure 6: On lines 15-17, does it matter that the export appears at the end?

In the `#%module-begin` case it does not. It is only relevant when
video-begin is used for functions.

> Is "this-syntax" a special keyword from syntax-parse?

Yes, it is analogous to "this" in OO programming.

> on line 24  why not "(exprs ... this-syntax)" so that you wouldn't
need to reverse on line 14?

Yes, this would make the example cleaner. We will fix it.


===========================================================================
Review #93C

> However, I wish that certain claims would either be softened (i.e. by adding a
"we believe that ...") or avoided.

We will look for places to soften the prose without affecting the overall
playful nature of the paper.

> One concern that came to mind during the explanation of the `#lang
racket/base` syntax is: How does a programmer know _which_ language to base
their DSL off of?

The choice of host language depends on the desired capabilities of the DSL. It
does require some exploration of the Racket ecosystem to know what others have
already created. For example a logic-programming DSL may want to use `#lang
datalog` as the host. `#lang racket/base` includes the "core" of Racket and
makes sense for as the host language for many functional DSLs.

> Do the authors feel that `Video` should supersede _all_ of these tools? I would be interested to know where the authors feel that their DSL falls short (if
anywhere).

In it's current state, Video is more suitable for editing short clips, such as
those found on Youtube or Twitch. Also, Video is not recommended for direct
manipulation of videos.

While we only evaluated Video in the context of editing the video proceedings
of a conference, we conjecture that our DSL-based approach can help the
workflow of all video editors.

We hope to improve Video so that it can accommodate "full" films and we will
extend the paper with a brief discussion of this and other future work.

> In section 4.2: "..., `clip`, incorporate traditional video files." And then
contrasts `clip` with `image`. What incorporates audio? 

We will clarify that `clip` produces both video and audio producers.

> In section 4.5: What happens if composites of a `multitrack` are different
lengths?

Each *track* starts playing at the same time. Authors insert `blank`s
to delay the start time of a track's producer. The length of a
multitrack is the length of its longest track, with implicit blanks
added at the end of every other track.

> In section 4.7: Here the use of `get-property` is so that the watermark is the
same length as the video, is this necessary (see last point)? If it is, why
doesn't `blank` require it?

Both `image` and `blank` do not require a length. In both cases, if
length is omitted, the length of the resulting producer is 'as long as
needed'. Which is to say it will be long enough to fill the remainder
of its current multitrack.

> "The last piece of the `begin` block is `code`." Do you mean that last piece is `export`?  I'm confused, I don't see `code` anywhere in Figure 6.

This is a typo that should be deleted.

> "The astute reader may wonder ...". Am I correct that this is not shown in
Figure 7, though there would be nested `begin`s during an actual elaboration?

This is correct.

> In section 6.3, As with the earlier comment, the nature of `multitrack`
intrigues me, I'm very curious to see the typing rule for that.

Unsurprisingly, the definition is somewhat long due to many supported options
but we will work to fit a summary into Figure 8 in the revised paper.

> It might be worth stating whether any custom graphics were required.

The graphical components were mostly made specifically for video.

We will extend section 7 with a brief description of the widget implementation.

> Is there no area where other DSL implementation techniques fare better than Racket's?

We will improve the prose to compare both pros and cons of other DSL
implementation techniques. For example, DSLs that do not require as much customization may benefit from choosing a host language that already supports the desired feature set, e.g., a lazy DSL.

===========================================================================
Review #93D

> (Those parentheses ...)

(I (don't (know (what (you (are (talking (about.))))))))

> I suggest, when introducing the 'multitrack' combinators,
that the authors foreshadow the fact that you may want
the tracks to have the same size/

The tracks do not need to be the same size.

Each *track* starts playing at the same time. Authors insert `blank`s
to delay the start time of a track's producer. The length of a
multitrack is the length of its longest track, with implicit blanks
added at the end of every other track.

> I would not be surprised if those programs used a simple declarative format that closely resembles their Video script.

They do! This is discussed in Section 3.

> I'm not really sold on the benefit of using this kind of a language. Video
editing I have done is very interactive: laying out clips, making small changes,
and playing back the result to see how it worked.

The recordings we had for RacketCon had all these problems but for this
particular case Video was not only fine, but actually much nicer than the
existing editors we used in previous years. This may not be true in general,
but our experience does demonstrate that there are cases where this sort of
editing is useful.

> you don't want to render the result before viewing since it
takes so long; most video editors use a low-resolution mode to quickly preview
changes.

See also above. Video indeed supports such a quick preview mode. There is a
`preview` button and function that lets you preview a clip at a low resolution
with playback controls. That, combined with `#:start` and `#:end` was a
mandatory requirement of Video, and without it we could not have edited the
RacketCon videos in a timely manner.

> I think a interesting use case is
for live applications like gaming livestreams: they will record video from their
computer but add elaborate overlays with subscriber information, space for
advertisements, and maybe a face camera.

Video would be useful for such a use case, and other short content from
websites such as Youtube and Twitch.

> All that said, the implementation seem technically fine. I probably wouldn't mind building a fleshed out interactive video editor on top of it.

See section 7.
